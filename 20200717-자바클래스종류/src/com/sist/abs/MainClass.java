package com.sist.abs;
/*
 * 클래스 종류
 * 	=일반클래스**
 * 	형식)
 * 		public class className
 * 		{
 * 			멤버변수, 공유변수
 * 			생성자
 * 			메소드
 * 		}
 * 		1) 데이터형으로만 사용 : 필요한 데이터를 모아서 관리 (캡슐화 : 데이터 은닉화 후 메소드를 통해 접근)
 * 													======    ===========
 * 													private   getter/setter
 * 		2) 액션클래스 : 기능만 가지고 있다(=메소드)
 * 		3) 변수 + 메소드 = 혼합
 * 		
 * ============
 * 	=추상클래스
 * 		public abstract class className
 * 		{
 * 			멤버변수/공유변수
 * 			구현이 안된 메소드 => 미완성 클래스  (생성자는 없다!!!=>미완성 클래스이기 때문)
 * 			구현이 된 메소드   
 * 		}
 * 		1) 스스로 메모리 할당 불가능
 * 		2) 생성 => 상속받은 클래스를 통해서 메모리에 저장
 * 		3) 단일 상속
 * 		4) 상속을 받은 클래스는 반드시 구현이 안된 메소드를 구현해서 사용
 * 		5) 여러 개의 클래스가 있는 경우 => 공통으로 적용된 메소드가 있는 경우 추상클래스 제작
 * 		6) 구분 : 메모리 할당시 클래스선언을 보고 구분
 * 			ex) A a=new A() : 일반클래스
 * 				A a=new B() : 추상클래스
 * 		7) 메소드 구현이 애매한 경우 (경우의 수가 많다 ex)default를 잡을 수 없는 경우)
 * 		8) 기본 틀이 제작되어 있어 구현이 쉽다
 * 		9) 요구사항 분석
 * 	=인터페이스 : 웹프로그램 
 * 		1) 추상클래스의 일종
 * 		2) 다중 상속 : implements 뒤에 ','로 구분 
 * 		public interface interfaceName
 * 		{
 * 			변수 : 상수형 변수!! => public final static 데이터형=값
 * 							  ===================
 * 								생략시 자동으로 추가(private, protected는 사용 불가)
 * 			메소드 : 구현이 안 된 메소드만 가지고 있다
 * 			** JDK1.8이상 => default로 구현된 메소드 작성 가능
 * 		} 
 * 		3) 인터페이스는 상위 클래스  => 상속을 내려야 사용 가능하기 때문
 * 			** 인터페이스는 클래스로부터 상속 받을 수 없다
 * 			** 인터페이스 to 인터페이스 : extends
 * 			** 인터페이스 to 클래스 : implements (받아서 구현해야 함)
 *  	=> 여러개의 서로 관련 없는 클래스를 연결해서 사용하는 프로그램
 *  	=> 결합성(다른 클래스에 영향을 미치는가)이 낮은 프로그램을 만들 경우 주로 사용(스프링)
 * ==========================================================================> 관련된 클래스가 여러개 => 묶어서 사용(통합)
 * 																				= 데이터베이스 연결, 웹프로그램(MVC)
 * 	=내부클래스  : 애플리케이션
 * 		=멤버클래스 : 두 개 이상의 클래스에서 한 개의 데이터를 공유할 경우 => 네트워크 프로그램, 쓰레드 프로그램, 빅데이터
 * 		class A
 * 		{
 * 			O, X, K
 * 		}
 * 		class B
 * 		{
 * 			A a=new A();
 * 			a.O, a.X, a.K
 * 		}
 * 		B b=new B();
 * 		B b1=new B();
 * 		=================================
 * 		class A
 * 		{
 * 			O, X, K
 * 			class B
 * 			{
 * 			}
 * 		}
 * 		=익명클래스 : 상속없이 => 오버라이딩 (윈도우 클래스)
 * 		class A
 * 		{
 * 		}
 * 		class B extends A,B => error!!
 * 		{
 * 		}
 *		class C extends A
 * 		{
 * 			B b=new B(){} = > 오버라이딩 가능!!
 * 		}
 * 
 * 		내부클래스
 * 		class A
 *		{
 *			class B
 *			{
 *			}
 *		}
 *		B b=new B(); => 사용할 수 없다
 *		A.B.b=new B(); => 상속받은 클래스를 다 써야 사용 가능  
 *		=> 상속 클래스에서 상속내린 클래스를 생성하는 게 더 일반적!
 *		class A
 *		{
 *			B b=new B();
 *			class B
 *			{
 *			}
 *		}
 */
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
